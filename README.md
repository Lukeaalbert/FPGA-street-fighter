# Street Fighter on Nexys A7 FPGA

### Contributors
 - lukeaalbert@gmail.com
 - farsoudi@gmail.com

### Demo

### Introduction

This project aims to recreate a Street Fighter like game in Verilog (the hardware description language). It is intended to be synthesized for and run on a Nexys A7 FPGA.

### User Interface

Remotes are used to play our game, which we built on breadboards. The two remotes are identical and are made from standard push buttons and a 5-position switch. The buttons are used for attack and shield, and the 5-position switch is used as a joystick, controlling a fighter’s movement. 

These controllers are interfaced to two separate Pmod ports JA and JC on the Nexys A7. Specifically, the following configuration is used:

- 3.3V → 1 input pin, JX6
- GND → 1 input pin, JX5
- 5-position switch→ 4 input pins, JX1 - JX4  
    - Left → JX1  
    - Right → JX2  
    - Up → JX3  
    - Down → JX4
- Attack → 1 input pin, JX9  
- Shield → 1 input pin, JX10

### Design

See a detailed diagram of the structure of our codebase below.

Something to keep in mind is that Verilog execution is concurrent, so while the P1/P2 Logic modules may seem far removed from their counterparts that fetch relevant sprites, data generated by the P1/P2 Logic modules are immediately available to the sprite fetching modules.

The P1/P2 Raw Controller Input Fetcher modules take the signals directly from the aforementioned Pmod ports and store them in a one-hot encoded array.

The Core Game module and its P1/P2 Logic sub-modules simulate all game logic. This includes but is not limited to attack/hitbox logic, shielding logic, movement logic, health logic, game over logic, and more. The P1/P2 Logic are specifically used to synchronize the raw controller inputs and store them in a more reliable and useful way for the VGA Bitchange module and its sub-modules.

The VGA Bitchange module is used to take the current state of the game along with all of its current state data and display it via VGA to a screen. The P1/P2 Logic to Sprite modules take the player's current state (produced by the P1/P2 Logic modules) and return RGB444 bits for a character. The Bars Display module takes both players’ health and shield levels and returns RBG444 bits for the bars (and their current levels) to be displayed.

Two main state machines are in the P1/P2 Logic modules. For each player, a 7-bit one-hot encoded array is produced. The MSB indicates whether the player is currently looking right (MSB == 0) or left (MSB == 1). The other bits indicate which action the player is taking.
- x000001 | Walking 
- x000010 | Crouching
- x000100 | Shielding
- x001000 | Jumping
- x010000 | Punching
- x100000 | Standing

The next state logic for each player is produced by the raw/debounced controller signals, the players’ health levels, and whether or not the game has concluded.

### Sprites

All sprites are stored in memory files (.mem) and are loaded into the Nexys A7’s Block RAM at the time of synthesis. Each line of a sprite memory file contains a single RBG444 value indicating the RGB pixel to be sent to the display. The sprite memory files are generated using a Python script (src/png_to_mem_sprite.py).

### Challenges

The most significant challenge of this project was learning to debug such a large HDL codebase. We found that the best way to overcome this challenge was to test our changes (synthesize and program the device) as often as possible to catch bugs early on. We also found that maintaining a clear, organized code hierarchy and well documented, readable code significantly helped with debugging.
